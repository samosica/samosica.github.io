<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on カクシカシカ</title><link>https://samosica.github.io/posts/</link><description>Recent content in Posts on カクシカシカ</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 24 Dec 2022 21:37:04 +0900</lastBuildDate><atom:link href="https://samosica.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Foliaを徹底検証する</title><link>https://samosica.github.io/posts/folia-formalization/</link><pubDate>Sat, 24 Dec 2022 21:37:04 +0900</pubDate><guid>https://samosica.github.io/posts/folia-formalization/</guid><description>
今年もクリスマスの時期がやってきました。この時期は全国各地で巨大なクリスマスツリー🎄が飾られていることと思います。 ツリーで思い出したのですが、AtCoderで2020年に出題されたFoliaという問題の解法をCoqで形式検証していたのでその話を書きます。
すべてのソースコードはここにあります。
問題 # 元の問題文は
https://atcoder.jp/contests/nomura2020/tasks/nomura2020_c にあります。行なった検証ではこれを一般化した次の問題を考えました。
非負整数 $n$ と非負整数の有限列 $s = (s_0, \dots, s_N)$ が与えられる。次の条件を満たす森が存在するか判定せよ。
条件1: $n$ 個の二分木から構成される 条件2: すべての $i = 0, \dots, N$ について、深さ $i$ の頂点がちょうど $s_i$ 個存在する さらに、もし存在するならば、そのような森の頂点数の最小値と最大値を計算せよ。
変更点は二分木を森に変えたこと、頂点数の最大値だけでなく最小値も計算することです。
なぜ森に変更したかというと、解法の正当性を証明するために必要だからです。 もし、元の問題のままで解法の正当性を $s$ に関する構造帰納法で示そうとすると、$s = s_0 :: s&amp;rsquo; $ のケースで使える帰納法の仮定は深さ1より下の層に関するものですが、これらの層が単一の二分木を形成するとは限らないので帰納法の仮定が使えません。 そこで、森に一般化することで帰納法の仮定を強め、帰納法が回るようにしています。
また、頂点数の最小値を考えるのは最小値、最大値を端点に持つ区間について考えたいからです。すぐ後で述べますが、この区間内の任意の整数は条件を満たす森の頂点数として実現可能であることが示せます。
扱う解法 # Foliaの解法にはいくつかのバリエーションがあるのですが、その中で検証したのはボトムアップの計算とトップダウンの計算を組み合わせた解法です。 ちなみにこの解法は公式の解説動画と同じものです。また、公式Editorialではトップダウンの計算のみを行なう解法が説明されています。
以下では問題のリンク先にある入力例1（$n = 1, N = 3, s = (0, 1, 1, 2)$）を使って解法を説明します。
手順1: sを下から上に見て、各深さで可能な頂点数の範囲を計算する 下から見るので、各深さではその深さとそれより下の層の条件のみを考慮します。上の層の条件、特に条件1はここでは考慮しません。 深さ3: ちょうど2個の頂点しか置けないので$[2, 2]$ 深さ2: 葉の頂点はちょうど1個必要。一方、深さ3には必ず2個の頂点があるので、葉でない頂点は最小1個（2個の頂点を子として持つ）、最大2個（2個の頂点を1つずつ子として持つ）。よって、$[1 + 1, 1 + 2] = [2, 3]$ 深さ1: 葉の頂点はちょうど1個必要。一方、深さ2には2から3個の頂点が置けるので、葉でない頂点は最小1個（深さ2に2個頂点を置いて、その上に1個置く）、最大3個（深さ2に3個頂点を置いて、それぞれの上に1個ずつ置く）。よって、$[1 + 1, 1 + 3] = [2, 4]$ 深さ0: 深さ1と同様の計算により$[1, 4]$ $n$ は $[1, 4]$ に含まれるので条件を満たす木が存在することが分かります。 手順2: sを上から下に見て、各深さで可能な頂点数の範囲を計算する。 上から見るので、各深さではそれより上の層の条件のみを考慮します。 深さ0: ちょうど $n$ 個の頂点しか置けないので $[1, 1]$ 深さ1: 深さ0には葉でない頂点が必ず $1 - s_0 = 1$ 個あるので、最小1個（下に1個置く）、最大2個（下に2個置く）。つまり、$[1, 2]$ 深さ2: 深さ1には葉でない頂点を $0\ (= 1 - s_1)$ から $1\ (= 2 - s_1)$ 個置けるので、最小0個、最大2個。つまり、$[0, 2]$ 深さ3: 同様の計算により $[0, 2]$ 手順3: 手順1、2で得られた範囲の共通部分を取り、すべての条件を考慮したときの頂点数の範囲を求める 深さ0: $[1, 4] \cap [1, 1] = [\max(1, 1), \min(4, 1)] = [1, 1]$ 深さ1: $[2, 4] \cap [1, 2] = [2, 2]$ 深さ2: $[2, 3] \cap [0, 2] = [2, 2]$ 深さ3: $[2, 2] \cap [0, 2] = [2, 2]$ したがって、条件を満たす木の頂点数の最小値、最大値はともに7であることが分かります やったこと # 前節で説明した解法をCoqで形式化し、その正しさを検証しました。 すべてのソースコードはここにあります。作業の流れは以下の通りです。</description></item></channel></rss>