<!doctype html><html lang=en><head><title>木が再帰的に定義されているときの重心分解 ::
カクシカシカ</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="もうちょっと詳しく # 木をtype 'a tree = T of 'a * 'a tree listの形で表現する1と、その重心分解が結構綺麗に書けます。
背景 # Balanced Tree (AtCoder Beginner Contest 291 Ex)は木を再帰的に重心分解する問題でした。 重心分解の実装でよく見かけるのは隣接リストで表現された木に対するものですが、再帰的に定義された木を使った方がその再帰構造が活きて、分かりやすい実装になるのではないかと思ったので試してみました。
実装 # 最初に再帰的に定義された木を用いて問題を解くプログラムを示します。実装言語はOCamlです。
(* 番号づけられた頂点を持つ木 *) (* T(i, v, ts) は根の番号が i、格納している値が v で、その下にある部分木のリストが ts である木を表す *) type &amp;#39;a indexed_tree = T of int * &amp;#39;a * &amp;#39;a indexed_tree list let root_index (T(i, _, _)) = i let root_value (T(_, v, _)) = v let subtrees (T(_, _, ts)) = ts (* 隣接リストから indexed_tree を構築する関数 *) (* al はグラフの隣接リストで、al."><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://samosica.github.io/posts/balanced-tree/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://samosica.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://samosica.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://samosica.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="木が再帰的に定義されているときの重心分解"><meta name=twitter:description content="もうちょっと詳しく: 木を`type 'a tree = T of 'a * 'a tree list`の形で表現すると、その重心分解が結構綺麗に書けます。"><meta property="og:title" content="木が再帰的に定義されているときの重心分解"><meta property="og:description" content="もうちょっと詳しく: 木を`type 'a tree = T of 'a * 'a tree list`の形で表現すると、その重心分解が結構綺麗に書けます。"><meta property="og:type" content="article"><meta property="og:url" content="https://samosica.github.io/posts/balanced-tree/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-07T17:30:00+09:00"><meta property="article:modified_time" content="2023-03-07T17:30:00+09:00"><meta property="og:site_name" content="カクシカシカ"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>カクシカシカ</span></a>
<span class=header__right><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>木が再帰的に定義されているときの重心分解</h1><div class=post-meta><time class=post-date>2023-03-07</time></div><div class=post-content><h3 id=もうちょっと詳しく>もうちょっと詳しく
<a href=#%e3%82%82%e3%81%86%e3%81%a1%e3%82%87%e3%81%a3%e3%81%a8%e8%a9%b3%e3%81%97%e3%81%8f class=h-anchor aria-hidden=true>#</a></h3><p>木を<code>type 'a tree = T of 'a * 'a tree list</code>の形で表現する<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>と、その重心分解が結構綺麗に書けます。</p><h3 id=背景>背景
<a href=#%e8%83%8c%e6%99%af class=h-anchor aria-hidden=true>#</a></h3><p><a href=https://atcoder.jp/contests/abc291/tasks/abc291_h>Balanced Tree (AtCoder Beginner Contest 291 Ex)</a>は木を再帰的に重心分解する問題でした。
重心分解の実装でよく見かけるのは隣接リストで表現された木に対するものですが、再帰的に定義された木を使った方がその再帰構造が活きて、分かりやすい実装になるのではないかと思ったので試してみました。</p><h3 id=実装>実装
<a href=#%e5%ae%9f%e8%a3%85 class=h-anchor aria-hidden=true>#</a></h3><p>最初に再帰的に定義された木を用いて問題を解くプログラムを示します。実装言語はOCamlです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 番号づけられた頂点を持つ木 *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* T(i, v, ts) は根の番号が i、格納している値が v で、その下にある部分木のリストが ts である木を表す *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a indexed_tree <span style=color:#f92672>=</span> <span style=color:#a6e22e>T</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>*</span> <span style=color:#66d9ef>&#39;</span>a indexed_tree <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> root_index <span style=color:#f92672>(</span><span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> <span style=color:#f92672>_,</span> <span style=color:#f92672>_))</span> <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> root_value <span style=color:#f92672>(</span><span style=color:#a6e22e>T</span><span style=color:#f92672>(_,</span> v<span style=color:#f92672>,</span> <span style=color:#f92672>_))</span> <span style=color:#f92672>=</span> v
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> subtrees <span style=color:#f92672>(</span><span style=color:#a6e22e>T</span><span style=color:#f92672>(_,</span> <span style=color:#f92672>_,</span> ts<span style=color:#f92672>))</span> <span style=color:#f92672>=</span> ts
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 隣接リストから indexed_tree を構築する関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* al はグラフの隣接リストで、al.(i) は i 番目の頂点と隣接する頂点の番号のリスト *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> dfs_tree al <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dfs p i <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> ()<span style=color:#f92672>,</span> List.filter_map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> j <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>if</span> j <span style=color:#f92672>=</span> p <span style=color:#66d9ef>then</span> <span style=color:#a6e22e>None</span> <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>dfs i j<span style=color:#f92672>))</span> al<span style=color:#f92672>.(</span>i<span style=color:#f92672>))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  dfs <span style=color:#f92672>(-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 各頂点にそれを根とする部分木のサイズを格納した木を返す関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> size_tree t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ts <span style=color:#f92672>=</span> List.map size_tree <span style=color:#f92672>(</span>subtrees t<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> count <span style=color:#f92672>=</span> List.fold_left <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> c t <span style=color:#f92672>-&gt;</span> c <span style=color:#f92672>+</span> root_value t<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span> ts <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>root_index t<span style=color:#f92672>,</span> count<span style=color:#f92672>,</span> ts<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 重心分解を行う関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> centroid_decomp t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  t: いま注目している木 *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* tt: t の上側にあった木のリスト *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  n: t と tt を合わせた木のサイズ *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* Note: tt のサイズは常に 1 以下になります。そのため、list の代わりに option を使ってもいいですが、 *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*       list の方がきれいに書けます。この小技は時々見ます *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> decomp t tt n <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* N.B. bigger のサイズは常に 1 以下 *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span>smaller<span style=color:#f92672>,</span> bigger<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> List.partition <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> t <span style=color:#f92672>-&gt;</span> root_value t <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&lt;=</span> n<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>subtrees t<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> bigger <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> t&#39; <span style=color:#f92672>::</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> ts&#39; <span style=color:#f92672>=</span> tt <span style=color:#f92672>@</span> smaller <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>(* t&#39; とそれ以外に分ける *)</span>
</span></span><span style=display:flex><span>      decomp t&#39; <span style=color:#f92672>[</span><span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>root_index t<span style=color:#f92672>,</span> n <span style=color:#f92672>-</span> root_value t&#39;<span style=color:#f92672>,</span> ts&#39;<span style=color:#f92672>)]</span> n <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>root_index t<span style=color:#f92672>,</span> ()<span style=color:#f92672>,</span> List.map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> t <span style=color:#f92672>-&gt;</span> decomp t [] <span style=color:#f92672>(</span>root_value t<span style=color:#f92672>))</span> <span style=color:#f92672>(</span>tt <span style=color:#f92672>@</span> subtrees t<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  decomp t [] <span style=color:#f92672>(</span>root_value t<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 木の各頂点の親を格納した配列を返す関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> parent_list_of_tree n t <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pl <span style=color:#f92672>=</span> Array.make n <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dfs p <span style=color:#f92672>(</span><span style=color:#a6e22e>T</span><span style=color:#f92672>(</span>i<span style=color:#f92672>,</span> <span style=color:#f92672>_,</span> ts<span style=color:#f92672>))</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    pl<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> t <span style=color:#f92672>-&gt;</span> dfs i t<span style=color:#f92672>)</span> ts <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  dfs <span style=color:#f92672>(-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> t<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  pl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> Scanf.scanf <span style=color:#e6db74>&#34; %d&#34;</span> Fun.id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> al <span style=color:#f92672>=</span> Array.make n [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>to</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      Scanf.scanf <span style=color:#e6db74>&#34; %d %d&#34;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> a b <span style=color:#f92672>-&gt;</span> 
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* 番号を 0 始まりにする *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> b <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        al<span style=color:#f92672>.(</span>a<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> b <span style=color:#f92672>::</span> al<span style=color:#f92672>.(</span>a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        al<span style=color:#f92672>.(</span>b<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> a <span style=color:#f92672>::</span> al<span style=color:#f92672>.(</span>b<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>done</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pl <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    al
</span></span><span style=display:flex><span>    <span style=color:#f92672>|&gt;</span> dfs_tree <span style=color:#75715e>(* 隣接リストを indexed_tree に変換 *)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|&gt;</span> size_tree <span style=color:#75715e>(* すべての部分木のサイズを計算 *)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|&gt;</span> centroid_decomp <span style=color:#75715e>(* 重心分解 *)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|&gt;</span> parent_list_of_tree n <span style=color:#75715e>(* indexed_tree から各頂点の親の配列に変換 *)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>to</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> pl<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* 番号を 1 始まりに戻す *)</span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>then</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> p <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    print_int p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      print_char <span style=color:#e6db74>&#39; &#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      print_newline()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p><code>centroid_decomposition</code>関数は一般的な実装と同じく次の手順で重心分解を行います。</p><ol><li>最初は木全体に注目する</li><li>注目している木の根の下に<code>(木のサイズ) * 2 > (全体の木のサイズ)</code>を満たす部分木が存在したら、その木を新たに注目する木とする。このとき、上側にある木を更新する。</li><li>そのような木がなくなったら、注目している木の根を重心として、それに隣接する部分木（上側の木を含む）に対して重心分解を行う。</li><li>(2), (3)を繰り返す</li></ol><figure class=center><img src=nonempty-bigger.png><figcaption class=center>(2)の操作</figcaption></figure><figure class=center><img src=empty-bigger.png alt="Hello Friend"><figcaption class=center>(3)の操作</figcaption></figure><p>プログラムでは<code>bigger = t' :: _</code>のケースが(2)に対応し、<code>bigger = []</code>のケースが(3)に対応します。これらのコード片は上の図を素直に表現したものになっています。</p><h3 id=比較>比較
<a href=#%e6%af%94%e8%bc%83 class=h-anchor aria-hidden=true>#</a></h3><p>次に比較対象として隣接リストで表現した木をそのまま用いて問題を解くプログラムを示します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 各頂点を根とする部分木のサイズを格納した配列を返す関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* al はグラフの隣接リストで、al.(i) は i 番目の頂点と隣接する頂点の番号のリスト *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> subtree_size al <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> ss <span style=color:#f92672>=</span> Array.make <span style=color:#f92672>(</span>Array.length al<span style=color:#f92672>)</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> loop p i <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> j <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> j <span style=color:#f92672>&lt;&gt;</span> p <span style=color:#66d9ef>then</span> <span style=color:#66d9ef>begin</span>
</span></span><span style=display:flex><span>        loop i j<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>        ss<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> ss<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>+</span> ss<span style=color:#f92672>.(</span>j<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span> al<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> loop <span style=color:#f92672>(-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  ss
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 重心分解を行う関数 *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 戻り値 pl は重心分解で得られる木において i の親が pl.(i) であることを表す *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* al はグラフの隣接リスト、ss は subtree_size から得られる部分木のサイズを格納した配列 *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> centroid_decomp al ss <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pl <span style=color:#f92672>=</span> Array.make <span style=color:#f92672>(</span>Array.length al<span style=color:#f92672>)</span> <span style=color:#f92672>(-</span><span style=color:#ae81ff>2</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  p: 直前に訪れた頂点 *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  i: いま訪れている頂点 *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* pc: 1つ前に見つけた重心 *)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(*  n: 全体の木のサイズ *)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> decomp p i pc n <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* j &lt;&gt; p: 戻らない *)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* pl.(j) = -2: すでに見つけた重心は無視する *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> j <span style=color:#f92672>=</span> List.find_opt <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> j <span style=color:#f92672>-&gt;</span> j <span style=color:#f92672>&lt;&gt;</span> p <span style=color:#f92672>&amp;&amp;</span> pl<span style=color:#f92672>.(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;&amp;</span> ss<span style=color:#f92672>.(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>&gt;</span> n<span style=color:#f92672>)</span> al<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> j <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> j <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      ss<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> n <span style=color:#f92672>-</span> ss<span style=color:#f92672>.(</span>j<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>      decomp i j pc n
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>      pl<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> pc<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>      List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> j <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>if</span> pl<span style=color:#f92672>.(</span>j<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span> <span style=color:#66d9ef>then</span> decomp i j i ss<span style=color:#f92672>.(</span>j<span style=color:#f92672>))</span> al<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span> decomp <span style=color:#f92672>(-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>(-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>)</span> <span style=color:#f92672>(</span>Array.length al<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  pl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> n <span style=color:#f92672>=</span> Scanf.scanf <span style=color:#e6db74>&#34; %d&#34;</span> Fun.id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> al <span style=color:#f92672>=</span> Array.make n [] <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>to</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>      Scanf.scanf <span style=color:#e6db74>&#34; %d %d&#34;</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> a b <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>(* 番号を 0 始まりにする *)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> b <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        al<span style=color:#f92672>.(</span>a<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> b <span style=color:#f92672>::</span> al<span style=color:#f92672>.(</span>a<span style=color:#f92672>);</span>
</span></span><span style=display:flex><span>        al<span style=color:#f92672>.(</span>b<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> a <span style=color:#f92672>::</span> al<span style=color:#f92672>.(</span>b<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>done</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> pl <span style=color:#f92672>=</span> subtree_size al <span style=color:#f92672>|&gt;</span> centroid_decomp al <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>to</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> pl<span style=color:#f92672>.(</span>i<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>(* 番号を 1 始まりに戻す *)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> p <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> p <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>then</span> p <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>else</span> p <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    print_int p<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span> <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>      print_char <span style=color:#e6db74>&#39; &#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      print_newline()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>このプログラムも十分分かりやすいのではないかと思うかもしれませんが、個人的には訪れていい頂点の条件が若干腑に落ちない感じがします。
その原因を辿ると、一次元的な配列の上で木を扱っていて、木が本来持っている構造が見えづらくなっていることが原因であるように思います。
ただもしかすると、実装が下手なだけで、うまく実装すれば問題ない可能性はあります。</p><p>上記2つのプログラムをAtCoderに提出しました。その結果は以下の通りです。</p><ul><li>再帰的に定義された木を用いる: 215 ms (<a href=https://atcoder.jp/contests/abc291/submissions/39381986>https://atcoder.jp/contests/abc291/submissions/39381986</a>)</li><li>隣接リストで表現された木をそのまま用いる: 141 ms (<a href=https://atcoder.jp/contests/abc291/submissions/39381925>https://atcoder.jp/contests/abc291/submissions/39381925</a>)</li></ul><p>前者は後者の1.5倍の時間がかかりました。この差の主な要因は後者が重心分解で得られる木を実際に構築していないことだと思われます。
なお、問題の時間制限は2秒なのでどちらも余裕があります。</p><h3 id=終わりに>終わりに
<a href=#%e7%b5%82%e3%82%8f%e3%82%8a%e3%81%ab class=h-anchor aria-hidden=true>#</a></h3><p>本記事では再帰的に定義された木に対する重心分解を実装しました。
今回のように木を代数的データ型で表現すると、それに対する操作が分かりやすく書けることがあります。
そのような機会があれば是非OCamlやHaskellなどの代数的データ型とパターンマッチの機能を備えた言語で書いてみてください。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>このように表現された木はrose treeと呼んだりするそうです (<a href=https://en.wikipedia.org/wiki/Rose_tree>Rose tree - Wikipedia</a>)&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://samosica.github.io/posts/folia-formalization/><span class=button__text>Foliaを徹底検証する</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>カクシカシカ</span></a><div class=copyright><span>© 2023 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>