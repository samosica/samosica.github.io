<!doctype html><html lang=en><head><title>AtCoderでOCamlを使うときのTips ::
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="OCaml で AtCoder のコンテストに出始めて約1年が経ちました。 知見が溜まってきたのでまとめておきます。
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://samosica.github.io/posts/handy-tips-for-using-ocaml-in-atcoder/><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=https://samosica.github.io/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=https://samosica.github.io/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=https://samosica.github.io/img/favicon.png><link href=/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="AtCoderでOCamlを使うときのTips"><meta name=twitter:description content="OCaml で AtCoder のコンテストに出始めて約1年が経ちました。
知見が溜まってきたのでまとめておきます。"><meta property="og:url" content="https://samosica.github.io/posts/handy-tips-for-using-ocaml-in-atcoder/"><meta property="og:site_name" content="カクシカシカ"><meta property="og:title" content="AtCoderでOCamlを使うときのTips"><meta property="og:description" content="OCaml で AtCoder のコンテストに出始めて約1年が経ちました。 知見が溜まってきたのでまとめておきます。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-19T18:00:00+09:00"><meta property="article:modified_time" content="2024-05-19T18:00:00+09:00"></head><body class=dark-theme><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>カクシカシカ</span>
</a><span class=header__right><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><article class=post><h1 class=post-title>AtCoderでOCamlを使うときのTips</h1><div class=post-meta><time class=post-date>2024-05-19</time></div><div class=post-content><p>OCaml で AtCoder のコンテストに出始めて約1年が経ちました。
知見が溜まってきたのでまとめておきます。</p><h2 id=注意>注意
<a href=#%e6%b3%a8%e6%84%8f class=h-anchor aria-hidden=true>#</a></h2><p>本記事の想定環境は2023年8月の言語アップデート後の AtCoder の環境です (<a href=https://img.atcoder.jp/file/language-update/language-list.html>参考</a>。2024年5月18日に確認)。
例えば、OCaml のバージョンは 5.0.0 を想定しています。</p><h2 id=scanfscanf-では-d-や-s-の前に半角スペースを付ける>Scanf.scanf では %d や %s の前に半角スペースを付ける
<a href=#scanfscanf-%e3%81%a7%e3%81%af-d-%e3%82%84-s-%e3%81%ae%e5%89%8d%e3%81%ab%e5%8d%8a%e8%a7%92%e3%82%b9%e3%83%9a%e3%83%bc%e3%82%b9%e3%82%92%e4%bb%98%e3%81%91%e3%82%8b class=h-anchor aria-hidden=true>#</a></h2><p>C言語の<code>scanf</code>は<code>%d</code>や<code>%s</code>だけでも値を読み込む前に空白文字 (スペース、タブ、改行)を読み飛ばしますが<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>、
OCaml の<code>scanf</code>はそれだけだと読み飛ばしません。読み飛ばすことを明示する必要があります。</p><p><code>%d</code>や<code>%s</code>の前に<code> </code>(半角スペース)を付けるとすべての種類の空白文字を読み飛ばします。また、<code>\n</code>を付けると改行だけを読み飛ばせます。
ただ、自分の経験では、AtCoder で値の区切り文字がどの空白文字なのかを気にしたことはないので、<code> </code>だけで十分だと思います。</p><p>加えて、とりあえず何にでも<code> </code>を付けておくといいと思います。
そうすることで、次のようなミスを防げます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* ケース1: &#34;1 2&#34;のように1行に2つの値が書かれていて、それを1つずつ読む *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* x を読んだ後、スペースを読み飛ばさないのでエラーになる *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> Scanf.scanf <span style=color:#e6db74>&#34;%d&#34;</span> Fun.id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> Scanf.scanf <span style=color:#e6db74>&#34;%d&#34;</span> Fun.id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  Printf.printf <span style=color:#e6db74>&#34;%d, %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* ケース2: 1行に1つ値が書かれていて、それを1つずつ読む *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 1行目を読んだ後、改行を読み飛ばさないのでエラーになる *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> i <span style=color:#f92672>=</span> 1 <span style=color:#66d9ef>to</span> 5 <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> Scanf.scanf <span style=color:#e6db74>&#34;%d&#34;</span> Fun.id <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>    Printf.printf <span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> x
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>done</span>
</span></span></code></pre></div><p>ただし、例外もあります。例えば、空文字列を読む必要があるときに<code> %s</code>を使ってしまうと意図しない文字列が読み込まれてしまいます。</p><h2 id=printfprintf-で-flush-する>Printf.printf で flush する
<a href=#printfprintf-%e3%81%a7-flush-%e3%81%99%e3%82%8b class=h-anchor aria-hidden=true>#</a></h2><p><code>%!</code>でできます。インタラクティブな問題で必要になります。</p><h2 id=64ビット符号付き整数が必要な問題が存在する>64ビット符号付き整数が必要な問題が存在する
<a href=#64%e3%83%93%e3%83%83%e3%83%88%e7%ac%a6%e5%8f%b7%e4%bb%98%e3%81%8d%e6%95%b4%e6%95%b0%e3%81%8c%e5%bf%85%e8%a6%81%e3%81%aa%e5%95%8f%e9%a1%8c%e3%81%8c%e5%ad%98%e5%9c%a8%e3%81%99%e3%82%8b class=h-anchor aria-hidden=true>#</a></h2><p>OCaml の<code>int</code>は最大でも<strong>63ビット</strong>符号付き整数の型なので、答えが64ビット符号付き整数にギリギリ収まる問題では<code>int</code>を使うと WA になります。</p><ul><li><a href=https://atcoder.jp/contests/abc321/tasks/abc321_d>AtCoder Beginner Contest 321 D - Set Menu</a></li><li><a href=https://atcoder.jp/contests/abc340/tasks/abc340_c>AtCoder Beginner Contest 340 C - Divide and Divide</a></li></ul><p>このような問題では代わりに<code>int64</code>を使います。
<code>int64</code>の基本的な演算は<a href=https://ocaml.org/manual/5.0/api/Int64.html>OCaml library : Int64</a>に書かれています。
また、<code>int64</code>の値を<code>Scanf.scanf</code>で読み込むときは<code>%Ld</code>を指定します。</p><h2 id=set-と-map-の-cardinal-は-θ1-ではない>Set と Map の cardinal は Θ(1) ではない
<a href=#set-%e3%81%a8-map-%e3%81%ae-cardinal-%e3%81%af-%ce%b81-%e3%81%a7%e3%81%af%e3%81%aa%e3%81%84 class=h-anchor aria-hidden=true>#</a></h2><p><code>Set.Make</code>、<code>Map.Make</code>によって生成されるモジュールにある<code>cardinal</code>関数は Θ(要素数) です。このことは実装を見ると分かります (ドキュメントには明記されていません)。</p><ul><li><a href=https://github.com/ocaml/ocaml/blob/e86f9e5d41217e8c824455206e854072b803b170/stdlib/set.ml#L415-L417>https://github.com/ocaml/ocaml/blob/e86f9e5d41217e8c824455206e854072b803b170/stdlib/set.ml#L415-L417</a></li><li><a href=https://github.com/ocaml/ocaml/blob/e86f9e5d41217e8c824455206e854072b803b170/stdlib/map.ml#L485-L487>https://github.com/ocaml/ocaml/blob/e86f9e5d41217e8c824455206e854072b803b170/stdlib/map.ml#L485-L487</a></li></ul><p>そのため、要素数が何回も必要になる問題で使うと TLE になります。</p><ul><li><a href=https://atcoder.jp/contests/abc343/tasks/abc343_d>AtCoder Beginner Contest 343 D - Diversity of Scores</a></li></ul><p>もし、要素数を Θ(1) で取得したいときは core の<code>Core.Map</code>モジュールを使うと良さそうです (自分はまだ使ったことがありません)。<code>Core.Map.length</code>が<code>cardinal</code>に相当します。</p><blockquote><p>length map returns the number of elements in map. O(1), but Tree.length is O(n).
(引用元: <a href=https://ocaml.org/p/core/v0.16.1/doc/Core/Map/index.html#val-length>core v0.16.1 · OCaml Package</a>)</p></blockquote><p>また、もし、要素間の大小関係に基づく操作が必要ないときは標準ライブラリの<code>Hashtbl</code>モジュールも使えます。<code>Hashtbl.length</code>が<code>cardinal</code>の代わりになります。</p><p>補足: <code>cardinal</code>関数を Θ(1) にしたいという要望はすでに GitHub の issue にあります。気になる方は<a href=https://github.com/ocaml/ocaml/issues/12866>Make Map length run in O(1) instead of O(n) · Issue #12866 · ocaml/ocaml</a>をご参照ください。</p><h2 id=iter-を多用しすぎると遅くなることがある>iter を多用しすぎると遅くなることがある
<a href=#iter-%e3%82%92%e5%a4%9a%e7%94%a8%e3%81%97%e3%81%99%e3%81%8e%e3%82%8b%e3%81%a8%e9%81%85%e3%81%8f%e3%81%aa%e3%82%8b%e3%81%93%e3%81%a8%e3%81%8c%e3%81%82%e3%82%8b class=h-anchor aria-hidden=true>#</a></h2><p>(余力ができたら追記します)</p><p>うろ覚えなのですが、以前 iter を多用したプログラムを書いたらかなり遅く、
それを for 文で書き直したら早くなったことがありました。</p><blockquote class=twitter-tweet><p lang=ja dir=ltr>AtCoder の OCaml 環境で iter を使ったプログラムが for で書き直したコードより 500 ms くらい遅い現象に遭遇した。どうやら最適化が弱いみたい。試しに手元で v4.14.1 + flambda 1 を使って、-O2 を付けてコンパイルしたらちょっと遅いくらいに、-O3 だとほぼ同じくらいになった</p>&mdash; samosica (@samosica) <a href="https://twitter.com/samosica/status/1705531373728256262?ref_src=twsrc%5Etfw">September 23, 2023</a></blockquote><script async src=https://platform.twitter.com/widgets.js></script><p>おそらく以下の提出のことだと思います (時系列が逆になっていますが、これは最初に書いた iter を使ったプログラムがうまく動かず、後で書き直したからです)。</p><ul><li>iter を使って書いた提出: <a href=https://atcoder.jp/contests/abc320/submissions/45785399>https://atcoder.jp/contests/abc320/submissions/45785399</a> (1900 ms)</li><li>for 文で書き直した提出: <a href=https://atcoder.jp/contests/abc320/submissions/45785346>https://atcoder.jp/contests/abc320/submissions/45785346</a> (1360 ms)</li></ul><p>簡単にしか調べていない、かつ、調べたのがかなり前なので不確かなのですが、
AtCoder の環境では flambda が有効になっていないために、iter を使ったプログラムの最適化が弱いようです。
上のツイートによると、flambda を有効にしたら<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>、時間差が縮まったそうです。</p><p>TLE が厳しい問題では iter の多用しすぎにお気を付けください。</p><h2 id=処理の途中で出てくる値をイテレーターの形で集める>処理の途中で出てくる値をイテレーターの形で集める
<a href=#%e5%87%a6%e7%90%86%e3%81%ae%e9%80%94%e4%b8%ad%e3%81%a7%e5%87%ba%e3%81%a6%e3%81%8f%e3%82%8b%e5%80%a4%e3%82%92%e3%82%a4%e3%83%86%e3%83%ac%e3%83%bc%e3%82%bf%e3%83%bc%e3%81%ae%e5%bd%a2%e3%81%a7%e9%9b%86%e3%82%81%e3%82%8b class=h-anchor aria-hidden=true>#</a></h2><p>例えば、グラフを探索しているときに訪れた頂点を記録したいことがあります。
そういうときは次のように可変変数に格納するのが一般的だと思います。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> visited_nodes <span style=color:#f92672>=</span> ref []
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dfs v <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  visited<span style=color:#f92672>.(</span>v<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  visited_nodes <span style=color:#f92672>:=</span> v <span style=color:#f92672>::</span> <span style=color:#f92672>!</span>visited_nodes<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> w <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> not visited<span style=color:#f92672>.(</span>w<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> dfs w
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span> al<span style=color:#f92672>.(</span>v<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  dfs 1<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* 訪れた順にするには反転する必要がある *)</span>
</span></span><span style=display:flex><span>  visited_nodes <span style=color:#f92672>:=</span> List.rev <span style=color:#f92672>!</span>visited_nodes<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>しかし、次のようにイテレーターの形で頂点を集めることもできます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* 集めた頂点を後で処理するための関数 k を引数に加える *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> dfs v k <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  visited<span style=color:#f92672>.(</span>v<span style=color:#f92672>)</span> <span style=color:#f92672>&lt;-</span> true<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>(* v を訪れたので k に v を渡す *)</span>
</span></span><span style=display:flex><span>  k v<span style=color:#f92672>;</span>
</span></span><span style=display:flex><span>  List.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> w <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> not visited<span style=color:#f92672>.(</span>w<span style=color:#f92672>)</span> <span style=color:#66d9ef>then</span> dfs w k
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span> al<span style=color:#f92672>.(</span>v<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* iter で使えるようにする *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> dfs v <span style=color:#f92672>=</span> Iter.from_iter <span style=color:#f92672>(</span>dfs v<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> () <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> visited_nodes <span style=color:#f92672>=</span> dfs 1 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>このように書くと次のような利点があります。</p><ul><li>値を集める処理と値を使う処理を分けて書ける。そうすると、二つの処理を同時に考えずに済むので、個人的には頭に優しいと思います。</li><li>値が得られた順に並ぶ。上の可変変数の例では最後にリストを反転させる必要がありました。</li><li>メモリにすべての値を置かないで処理が行なえ、速度の向上が期待できる。リストや配列の形で保持、操作すると最初の値はもちろん、中間結果もメモリに格納する必要があります。</li></ul><p>この方法を使ったプログラムの例をいくつか載せておきます。</p><ul><li><a href=https://atcoder.jp/contests/abc350/submissions/52583256>https://atcoder.jp/contests/abc350/submissions/52583256</a> (AtCoder Beginner Contest 350 C)。入れ替える要素の組をイテレーターで持っています。</li><li><a href=https://atcoder.jp/contests/abc337/submissions/52467430>https://atcoder.jp/contests/abc337/submissions/52467430</a> (AtCoder Beginner Contest 337 D)。ある行 (あるいは列)のある区間をすべて<code>o</code>にするために必要な回数をイテレーターで持っています。</li></ul><h2 id=毎回決まった量加算するループを-iter-を使って書く>毎回決まった量加算するループを iter を使って書く
<a href=#%e6%af%8e%e5%9b%9e%e6%b1%ba%e3%81%be%e3%81%a3%e3%81%9f%e9%87%8f%e5%8a%a0%e7%ae%97%e3%81%99%e3%82%8b%e3%83%ab%e3%83%bc%e3%83%97%e3%82%92-iter-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e6%9b%b8%e3%81%8f class=h-anchor aria-hidden=true>#</a></h2><p>C++ で言うところの<code>for(int i = l; i &lt; r; i += step){ ... }</code>は iter を使って次のように書けます<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>Iter.iterate <span style=color:#f92672>((+)</span> step<span style=color:#f92672>)</span> l
</span></span><span style=display:flex><span><span style=color:#f92672>|&gt;</span> Iter.take_while <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> i <span style=color:#f92672>-&gt;</span> i <span style=color:#f92672>&lt;</span> r<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>|&gt;</span> Iter.iter <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> i <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>...)</span>
</span></span></code></pre></div><p>iter には<code>Iter.int_range_by</code>というぴったりそうな関数がありますが、上のプログラムと異なる動作をするケースがあるので注意が必要です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> step <span style=color:#f92672>=</span> 2 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> l <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> r <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>1 <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* for(int i = l; i &lt; r; i += step) のつもり *)</span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* 何も出力しないでほしいが、実際は 0 を出力する *)</span>
</span></span><span style=display:flex><span>Iter.int_range_by <span style=color:#f92672>~</span>step l r
</span></span><span style=display:flex><span><span style=color:#f92672>|&gt;</span> Iter.iter <span style=color:#f92672>(</span>Printf.printf <span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><p>(<code>step > 0</code>で)<code>l >= r</code>のときは何もしないように条件分岐すれば問題ありませんが、焦っていると忘れてしまうかもしれないので、個人的には最初の方法で書くのがオススメです。</p><h2 id=未定を-none-で表現するときの最小値最大値>未定を None で表現するときの最小値、最大値
<a href=#%e6%9c%aa%e5%ae%9a%e3%82%92-none-%e3%81%a7%e8%a1%a8%e7%8f%be%e3%81%99%e3%82%8b%e3%81%a8%e3%81%8d%e3%81%ae%e6%9c%80%e5%b0%8f%e5%80%a4%e6%9c%80%e5%a4%a7%e5%80%a4 class=h-anchor aria-hidden=true>#</a></h2><p>最小値 (または最大値)を動的計画法で求めたいとします。
テーブルの初期値には<code>max_int</code>や<code>-1</code>などの具体的な値を指定することが多いですが、そうすると途中の計算がおかしくならないか気を配る必要があります。
そのため、代わりに<code>None</code>を指定して未定とそれ以外を明確に区別することにします。
このとき、テーブルの値は<code>'a option</code>になるわけですが、<code>'a option</code>の最小値 (または最大値)はどのように計算すればいいでしょうか。</p><h3 id=最大値>最大値
<a href=#%e6%9c%80%e5%a4%a7%e5%80%a4 class=h-anchor aria-hidden=true>#</a></h3><p>(注意: 以下では実行速度のことはあまり考えていません。記述量だけを考慮しています)</p><p>少なくとも AtCoder の環境では<code>None &lt;= Some v</code>で、<code>Some v &lt;= Some w</code>と<code>v &lt;= w</code>が同値なので、単に<code>max</code>と書けます<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><h3 id=最小値>最小値
<a href=#%e6%9c%80%e5%b0%8f%e5%80%a4 class=h-anchor aria-hidden=true>#</a></h3><p>単に<code>min</code>と書くことはできません。色々試してきましたが、結局のところ、次のような関数をあらかじめ定義しておくのが良さそうです<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> lift <span style=color:#f92672>~</span>f o1 o2 <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> o1 o2 <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>None</span><span style=color:#f92672>,</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> o2
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#f92672>_,</span> <span style=color:#a6e22e>None</span> <span style=color:#f92672>-&gt;</span> o1
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Some</span> x1<span style=color:#f92672>,</span> <span style=color:#a6e22e>Some</span> x2 <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Some</span> <span style=color:#f92672>(</span>f x1 x2<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>この<code>lift</code>を使うと、2つの値の最小値を取る関数は<code>lift ~f:min</code>と書けます。</p><p>この方法は最大値でも使えます。両方で同じ方法を使えば書き方を迷う時間を減らせます。
さらには、一般の二項演算でも使えて汎用性が高いです。</p><h2 id=参考資料>参考資料
<a href=#%e5%8f%82%e8%80%83%e8%b3%87%e6%96%99 class=h-anchor aria-hidden=true>#</a></h2><ul><li><a href=https://ocaml.org/manual/5.0/api/Scanf.html>OCaml library : Scanf</a></li><li><a href=https://ocaml.org/manual/5.0/api/Sys.html#VALint_size>OCaml library : Sys</a></li><li><a href="https://docs.google.com/spreadsheets/d/1HXyOXt5bKwhKWXruzUvfMFHQtBxfZQ0047W7VVObnXI/edit#gid=0">AtCoder 2023/1 Language Update</a></li><li><a href=https://github.com/ocaml/opam-repository/pull/17541>Try a new layout for compiler flags for OCaml 4.12.0 (and add 4.12.0~alpha1) by AltGr · Pull Request #17541 · ocaml/opam-repository</a></li><li><a href=https://stackoverflow.com/questions/70665781/how-to-use-flambda-with-dune-in-ocaml>How to use Flambda with dune in ocaml? - Stack Overflow</a></li><li><a href=https://discuss.ocaml.org/t/experimental-new-layout-for-the-ocaml-variants-packages-in-opam-repository/6779>Experimental new layout for the ocaml-variants packages in opam-repository - Ecosystem - OCaml</a></li><li><a href=https://ocamlverse.net/content/iterators.html>Iterators And Streams | OCamlverse</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>これが仕様としてどこかに明記されているかは不明です。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>記憶違いでなければ、<code>ocaml-base-compiler</code>の代わりに<code>ocaml-variants.4.14.1+options</code>と<code>ocaml-option-flambda.1</code>をインストールしたはずです。これらのパッケージについては<a href=/posts/handy-tips-for-using-ocaml-in-atcoder/#参考資料>参考資料</a>をご覧ください。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>元のコードも OCaml のコードも<code>l</code>、<code>r</code>、<code>step</code>がオーバーフローが起こらない程度に小さいと暗に仮定していることにお気を付けください。例えば、OCaml だと<code>l = 0, r = max_int, step = max_int - 1</code>のとき、オーバーフローが起こり、<code>i</code>が負の数になります。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>これが仕様としてドキュメントに明記されているかは不明です。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>(<code>f</code>が結合律を満たすとき、)<code>lift ~f</code>は<code>f</code>を演算に持つ半群に単位元を追加して得られるモノイドの演算です。
Haskell を使っている方にはお馴染みかもしれません。&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=https://samosica.github.io/posts/handy-tips-for-using-koka-in-atcoder/><span class=button__text>AtCoderでKokaを使うときのTips</span>
<span class=button__icon>→</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span><span class=logo__text>カクシカシカ</span></a><div class=copyright><span>© 2024 Powered by
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a></span>
<span>Theme created by
<a href=https://twitter.com/panr target=_blank rel=noopener>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>